# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: queries.sql
import datetime
from typing import Optional

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

CREATE_TWEET = """-- name: create_tweet \\:exec
insert into tweet (id, tweeted_at, text, replies, retweets, likes, views, user_handle, parent_id)
values (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9)
"""


class CreateTweetParams(pydantic.BaseModel):
    id: int
    tweeted_at: datetime.datetime
    text: str
    replies: int
    retweets: int
    likes: int
    views: int
    user_handle: str
    parent_id: Optional[int]


CREATE_USER = """-- name: create_user \\:exec
insert into "user" (handle, name, description, following, followers)
values (:p1, :p2, :p3, :p4, :p5)
"""


class CreateUserParams(pydantic.BaseModel):
    handle: str
    name: str
    description: Optional[str]
    following: int
    followers: int


DOES_TWEET_EXIST = """-- name: does_tweet_exist \\:one
select exists(select 1 from tweet where id=:p1)
"""


DOES_USER_EXIST = """-- name: does_user_exist \\:one
select exists(select 1 from "user" where handle=:p1)
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_tweet(self, arg: CreateTweetParams) -> None:
        await self._conn.execute(
            sqlalchemy.text(CREATE_TWEET),
            {
                "p1": arg.id,
                "p2": arg.tweeted_at,
                "p3": arg.text,
                "p4": arg.replies,
                "p5": arg.retweets,
                "p6": arg.likes,
                "p7": arg.views,
                "p8": arg.user_handle,
                "p9": arg.parent_id,
            },
        )

    async def create_user(self, arg: CreateUserParams) -> None:
        await self._conn.execute(
            sqlalchemy.text(CREATE_USER),
            {
                "p1": arg.handle,
                "p2": arg.name,
                "p3": arg.description,
                "p4": arg.following,
                "p5": arg.followers,
            },
        )

    async def does_tweet_exist(self, *, id: int) -> Optional[bool]:
        row = (await self._conn.execute(sqlalchemy.text(DOES_TWEET_EXIST), {"p1": id})).first()
        if row is None:
            return None
        return row[0]

    async def does_user_exist(self, *, handle: str) -> Optional[bool]:
        row = (await self._conn.execute(sqlalchemy.text(DOES_USER_EXIST), {"p1": handle})).first()
        if row is None:
            return None
        return row[0]
